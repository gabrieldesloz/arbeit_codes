-- $RCSfile: bip_dsp48_macro_pkg_v2_1.vhd,v $ $Date: 2011/05/26 11:57:25 $ $Revision: 1.9 $
-------------------------------------------------------------------------------
--  (c) Copyright 2008, 2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
-------------------------------------------------------------------------------
-- Shared package for constants, functions and component statements
-------------------------------------------------------------------------------

-- ### WARNING!!!  DO NOT EDIT THIS FILE BY HAND!  USE cp_to_sim.sh IN hdl/ INSTEAD! ###

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library xilinxcorelib;
use xilinxcorelib.bip_usecase_utils_pkg_v2_0.all;
use xilinxcorelib.bip_utils_pkg_v2_0.all;

package bip_dsp48_macro_pkg_v2_1 is

  constant ci_num_opmodes : integer := 64;

  function fn_dsp48_macro_v2_1_check_generics (  --deliberately no defaults.
    P_VERBOSITY       : integer;
    P_MODEL_TYPE      : integer;
    P_XDEVICEFAMILY   : string;
    P_HAS_CE          : integer;
    P_HAS_SCLR        : integer;
    P_HAS_CARRYCASCIN : integer;
    P_HAS_ACIN        : integer;
    P_HAS_BCIN        : integer;
    P_HAS_A           : integer;
    P_HAS_B           : integer;
    P_HAS_D           : integer;
    P_HAS_CONCAT      : integer;
    P_A_WIDTH         : integer;
    P_B_WIDTH         : integer;
    P_C_WIDTH         : integer;
    P_D_WIDTH         : integer;
    P_CONCAT_WIDTH    : integer;
    P_SEL_WIDTH       : integer;
    P_LATENCY         : integer;
    P_OPMODES         : string;
    P_REG_CONFIG      : string
    ) return integer;

  --core_if on component xbip_dsp48_macro
  component xbip_dsp48_macro
    generic (
      C_VERBOSITY        : integer := 0;  -- 0 = Errors 1 = +Warnings, 2 = +Notes and tips
      C_MODEL_TYPE       : integer := 0;  -- 0 = synth, 1 = RTL
      C_XDEVICEFAMILY    : string  := "virtex5";         -- Target device

      C_HAS_CE           : integer := 0;  -- 0=No CEs, 1=Has any type of CE (global, ganged, per-register)
      C_HAS_INDEP_CE     : integer := 0;  -- 0=Global CE, 1=Ganged CE for each input path, 2=Unique CE for every register

      C_HAS_CED          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(2 downto 0) enables individual CEs
      C_HAS_CEA          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(3 downto 0) enables individual CEs
      C_HAS_CEB          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(3 downto 0) enables individual CEs
      C_HAS_CEC          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(4 downto 0) enables individual CEs
      C_HAS_CECONCAT     : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(4 downto 2) enables individual CEs
      C_HAS_CEM          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(0 downto 0) enables individual CEs
      C_HAS_CEP          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(0 downto 0) enables individual CEs
      C_HAS_CESEL        : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(4 downto 0) enables individual CEs

      C_HAS_SCLR         : integer := 0;  -- 0=No SCLRs, 1=Has any type of SCLR (global, ganged)
      C_HAS_INDEP_SCLR   : integer := 0;  -- 0=Global CE, 1=Ganged SCLR for each input path

      C_HAS_SCLRD        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables D SCLR pin
      C_HAS_SCLRA        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables A SCLR pin
      C_HAS_SCLRB        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables B SCLR pin
      C_HAS_SCLRC        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables C SCLR pin
      C_HAS_SCLRM        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables M SCLR pin
      C_HAS_SCLRP        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables P SCLR pin
      C_HAS_SCLRCONCAT   : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables CONCAT SCLR pin
      C_HAS_SCLRSEL      : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables SEL SCLR pin

      C_HAS_CARRYCASCIN  : integer := 0;  -- 0=No CARRYCASCIN input, 1=Has CARRYCASCIN input (must be reflected in instructions)
      C_HAS_CARRYIN      : integer := 0;  -- 0=No CARRYIN input, 1=Has CARRYIN input (must be reflected in instructions)
      C_HAS_ACIN         : integer := 0;  -- 0=No ACIN input, 1=Has ACIN input (must be reflected in instructions)
      C_HAS_BCIN         : integer := 0;  -- 0=No BCIN input, 1=Has BCIN input (must be reflected in instructions)
      C_HAS_PCIN         : integer := 0;  -- 0=No PCIN input, 1=Has PCIN input (must be reflected in instructions)
      C_HAS_A            : integer := 1;  -- 0=No A input, 1=Has A input (must be reflected in instructions)
      C_HAS_B            : integer := 1;  -- 0=No B input, 1=Has B input (must be reflected in instructions)
      C_HAS_D            : integer := 1;  -- 0=No D input, 1=Has D input (must be reflected in instructions)
      C_HAS_CONCAT       : integer := 0;  -- 0=No CONCAT input, 1=Has CONCAT input (must be reflected in instructions)
      C_HAS_C            : integer := 0;  -- 0=No C input, 1=Has C input (must be reflected in instructions)
      C_A_WIDTH          : integer := ci_dsp48_b_width;  -- Width of A input bus (if present)
      C_B_WIDTH          : integer := ci_dsp48_b_width;  -- Width of B input bus (if present)
      C_C_WIDTH          : integer := ci_dsp48_c_width;  -- Width of C input bus (if present)
      C_D_WIDTH          : integer := 0;  -- Width of D input bus (if present)
      C_CONCAT_WIDTH     : integer := 0;  -- Width of CONCAT input bus (if present)
      C_P_MSB            : integer := ci_dsp48_p_width-1;  -- MSB of P output
      C_P_LSB            : integer := 0;  -- LSB of P output
      C_SEL_WIDTH        : integer := 5;  -- Width of instruction ROM select port (0 to 6, based on C_OPMODES)
      C_HAS_ACOUT        : integer := 0;  -- 0=No ACOUT port, 1=Has ACOUT cascade port
      C_HAS_BCOUT        : integer := 0;  -- 0=No BCOUT port, 1=Has BCOUT cascade port
      C_HAS_CARRYCASCOUT : integer := 0;  -- 0=No CARRYCASCOUT port, 1=Has CARRYCASCOUT cascade port
      C_HAS_CARRYOUT     : integer := 0;  -- 0=No CARRYOUT port, 1=Has CARRYOUT port
      C_HAS_PCOUT        : integer := 0;  -- 0=No PCOUT port, 1=Has PCOUT cascade port
      C_CONSTANT_1       : integer := 1;  -- Constant to allow A to pass through multiplier with no B input
      C_LATENCY          : integer := -1;  -- Core latency and register allocation; -1=Automatic, 0 to 127=Tiered, 128=Expert
      C_OPMODES          : string  := "0000000000000000000";  -- Instruction opmodes to implement (comma-separated string)
      C_REG_CONFIG       : string  := "00000000000000000000000000000000";  -- Register configuration string (ignored unless C_LATENCY=128)
      C_TEST_CORE        : integer := 0  -- 0 = normal release core behavour 1 = generate a test core
      );
    port (
      CLK          : in  std_logic                                                             := '1';  -- Rising-edge clock
      CE           : in  std_logic                                                             := '1';  -- Active-high global clock enable
      SCLR         : in  std_logic                                                             := '0';  -- Active-high global synchronous reset
      SEL          : in  std_logic_vector(C_SEL_WIDTH+boolean'pos(C_SEL_WIDTH = 0)-1 downto 0) := (others => '0');  --Guard against -1 to 0 when C_SEL_WIDTH=0
      CARRYCASCIN  : in  std_logic                                                             := '0';
      CARRYIN      : in  std_logic                                                             := '0';
      PCIN         : in  std_logic_vector(ci_dsp48_p_width-1 downto 0)                         := (others => '0');
      ACIN         : in  std_logic_vector(fn_dsp48_a_width(C_XDEVICEFAMILY)-1 downto 0)        := (others => '0');
      BCIN         : in  std_logic_vector(ci_dsp48_b_width-1 downto 0)                         := (others => '0');
      A            : in  std_logic_vector(C_A_WIDTH-1 downto 0)                                := (others => '0');
      B            : in  std_logic_vector(C_B_WIDTH-1 downto 0)                                := (others => '0');
      C            : in  std_logic_vector(C_C_WIDTH-1 downto 0)                                := (others => '0');
      D            : in  std_logic_vector(C_D_WIDTH-1 downto 0)                                := (others => '0');
      CONCAT       : in  std_logic_vector(C_CONCAT_WIDTH-1 downto 0)                           := (others => '0');
      ACOUT        : out std_logic_vector(fn_dsp48_a_width(C_XDEVICEFAMILY)-1 downto 0)        := (others => '0');
      BCOUT        : out std_logic_vector(ci_dsp48_b_width-1 downto 0)                         := (others => '0');
      CARRYOUT     : out std_logic                                                             := '0';
      CARRYCASCOUT : out std_logic                                                             := '0';
      PCOUT        : out std_logic_vector(ci_dsp48_p_width-1 downto 0)                         := (others => '0');
      P            : out std_logic_vector(C_P_MSB-C_P_LSB downto 0)                            := (others => '0');

      CED          : in  std_logic                                                             := '1';  -- Ganged CE for D (Spartan)
      CED1         : in  std_logic                                                             := '1';
      CED2         : in  std_logic                                                             := '1';
      CED3         : in  std_logic                                                             := '1';
      CEA          : in  std_logic                                                             := '1';  -- Ganged CE for A (Spartan)
      CEA1         : in  std_logic                                                             := '1';
      CEA2         : in  std_logic                                                             := '1';
      CEA3         : in  std_logic                                                             := '1';
      CEA4         : in  std_logic                                                             := '1';
      CEB          : in  std_logic                                                             := '1';  -- Ganged CE for B (Spartan)
      CEB1         : in  std_logic                                                             := '1';
      CEB2         : in  std_logic                                                             := '1';
      CEB3         : in  std_logic                                                             := '1';
      CEB4         : in  std_logic                                                             := '1';
      CECONCAT     : in  std_logic                                                             := '1';  -- Ganged CE for CONCAT (Spartan)
      CECONCAT3    : in  std_logic                                                             := '1';
      CECONCAT4    : in  std_logic                                                             := '1';
      CECONCAT5    : in  std_logic                                                             := '1';
      CEC          : in  std_logic                                                             := '1';  -- Ganged CE for C (Spartan)
      CEC1         : in  std_logic                                                             := '1';
      CEC2         : in  std_logic                                                             := '1';
      CEC3         : in  std_logic                                                             := '1';
      CEC4         : in  std_logic                                                             := '1';
      CEC5         : in  std_logic                                                             := '1';
      CEM          : in  std_logic                                                             := '1';
      CEP          : in  std_logic                                                             := '1';
      CESEL        : in  std_logic                                                             := '1';  -- Ganged CE for SEL (Spartan)
      CESEL1       : in  std_logic                                                             := '1';
      CESEL2       : in  std_logic                                                             := '1';
      CESEL3       : in  std_logic                                                             := '1';
      CESEL4       : in  std_logic                                                             := '1';
      CESEL5       : in  std_logic                                                             := '1';
      SCLRD        : in  std_logic                                                             := '0';
      SCLRA        : in  std_logic                                                             := '0';
      SCLRB        : in  std_logic                                                             := '0';
      SCLRCONCAT   : in  std_logic                                                             := '0';
      SCLRC        : in  std_logic                                                             := '0';
      SCLRM        : in  std_logic                                                             := '0';
      SCLRP        : in  std_logic                                                             := '0';
      SCLRSEL      : in  std_logic                                                             := '0'
      );
    --core_if off
  end component;

  --core_if on component bip_dsp48_macro_synth
  component bip_dsp48_macro_synth
    generic (
      C_VERBOSITY        : integer := 0;  -- 0 = Errors 1 = +Warnings, 2 = +Notes and tips
      C_MODEL_TYPE       : integer := 0;  -- 0 = synth, 1 = RTL
      C_XDEVICEFAMILY    : string  := "virtex5";         -- Target device

      C_HAS_CE           : integer := 0;  -- 0=No CEs, 1=Has any type of CE (global, ganged, per-register)
      C_HAS_INDEP_CE     : integer := 0;  -- 0=Global CE, 1=Ganged CE for each input path, 2=Unique CE for every register

      C_HAS_CED          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(2 downto 0) enables individual CEs
      C_HAS_CEA          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(3 downto 0) enables individual CEs
      C_HAS_CEB          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(3 downto 0) enables individual CEs
      C_HAS_CEC          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(4 downto 0) enables individual CEs
      C_HAS_CECONCAT     : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(4 downto 2) enables individual CEs
      C_HAS_CEM          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(0 downto 0) enables individual CEs
      C_HAS_CEP          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(0 downto 0) enables individual CEs
      C_HAS_CESEL        : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(4 downto 0) enables individual CEs

      C_HAS_SCLR         : integer := 0;  -- 0=No SCLRs, 1=Has any type of SCLR (global, ganged)
      C_HAS_INDEP_SCLR   : integer := 0;  -- 0=Global CE, 1=Ganged SCLR for each input path

      C_HAS_SCLRD        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables D SCLR pin
      C_HAS_SCLRA        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables A SCLR pin
      C_HAS_SCLRB        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables B SCLR pin
      C_HAS_SCLRC        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables C SCLR pin
      C_HAS_SCLRM        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables M SCLR pin
      C_HAS_SCLRP        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables P SCLR pin
      C_HAS_SCLRCONCAT   : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables CONCAT SCLR pin
      C_HAS_SCLRSEL      : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables SEL SCLR pin

      C_HAS_CARRYCASCIN  : integer := 0;  -- 0=No CARRYCASCIN input, 1=Has CARRYCASCIN input (must be reflected in instructions)
      C_HAS_CARRYIN      : integer := 0;  -- 0=No CARRYIN input, 1=Has CARRYIN input (must be reflected in instructions)
      C_HAS_ACIN         : integer := 0;  -- 0=No ACIN input, 1=Has ACIN input (must be reflected in instructions)
      C_HAS_BCIN         : integer := 0;  -- 0=No BCIN input, 1=Has BCIN input (must be reflected in instructions)
      C_HAS_PCIN         : integer := 0;  -- 0=No PCIN input, 1=Has PCIN input (must be reflected in instructions)
      C_HAS_A            : integer := 1;  -- 0=No A input, 1=Has A input (must be reflected in instructions)
      C_HAS_B            : integer := 1;  -- 0=No B input, 1=Has B input (must be reflected in instructions)
      C_HAS_D            : integer := 1;  -- 0=No D input, 1=Has D input (must be reflected in instructions)
      C_HAS_CONCAT       : integer := 0;  -- 0=No CONCAT input, 1=Has CONCAT input (must be reflected in instructions)
      C_HAS_C            : integer := 0;  -- 0=No C input, 1=Has C input (must be reflected in instructions)
      C_A_WIDTH          : integer := ci_dsp48_b_width;  -- Width of A input bus (if present)
      C_B_WIDTH          : integer := ci_dsp48_b_width;  -- Width of B input bus (if present)
      C_C_WIDTH          : integer := ci_dsp48_c_width;  -- Width of C input bus (if present)
      C_D_WIDTH          : integer := 0;  -- Width of D input bus (if present)
      C_CONCAT_WIDTH     : integer := 0;  -- Width of CONCAT input bus (if present)
      C_P_MSB            : integer := ci_dsp48_p_width-1;  -- MSB of P output
      C_P_LSB            : integer := 0;  -- LSB of P output
      C_SEL_WIDTH        : integer := 5;  -- Width of instruction ROM select port (0 to 6, based on C_OPMODES)
      C_HAS_ACOUT        : integer := 0;  -- 0=No ACOUT port, 1=Has ACOUT cascade port
      C_HAS_BCOUT        : integer := 0;  -- 0=No BCOUT port, 1=Has BCOUT cascade port
      C_HAS_CARRYCASCOUT : integer := 0;  -- 0=No CARRYCASCOUT port, 1=Has CARRYCASCOUT cascade port
      C_HAS_CARRYOUT     : integer := 0;  -- 0=No CARRYOUT port, 1=Has CARRYOUT port
      C_HAS_PCOUT        : integer := 0;  -- 0=No PCOUT port, 1=Has PCOUT cascade port
      C_CONSTANT_1       : integer := 1;  -- Constant to allow A to pass through multiplier with no B input
      C_LATENCY          : integer := -1;  -- Core latency and register allocation; -1=Automatic, 0 to 127=Tiered, 128=Expert
      C_OPMODES          : string  := "0000000000000000000";  -- Instruction opmodes to implement (comma-separated string)
      C_REG_CONFIG       : string  := "00000000000000000000000000000000";  -- Register configuration string (ignored unless C_LATENCY=128)
      C_TEST_CORE        : integer := 0  -- 0 = normal release core behavour 1 = generate a test core
      );
    port (
      CLK          : in  std_logic                                                             := '1';  -- Rising-edge clock
      CE           : in  std_logic                                                             := '1';  -- Active-high global clock enable
      SCLR         : in  std_logic                                                             := '0';  -- Active-high global synchronous reset
      SEL          : in  std_logic_vector(C_SEL_WIDTH+boolean'pos(C_SEL_WIDTH = 0)-1 downto 0) := (others => '0');  --Guard against -1 to 0 when C_SEL_WIDTH=0
      CARRYCASCIN  : in  std_logic                                                             := '0';
      CARRYIN      : in  std_logic                                                             := '0';
      PCIN         : in  std_logic_vector(ci_dsp48_p_width-1 downto 0)                         := (others => '0');
      ACIN         : in  std_logic_vector(fn_dsp48_a_width(C_XDEVICEFAMILY)-1 downto 0)        := (others => '0');
      BCIN         : in  std_logic_vector(ci_dsp48_b_width-1 downto 0)                         := (others => '0');
      A            : in  std_logic_vector(C_A_WIDTH-1 downto 0)                                := (others => '0');
      B            : in  std_logic_vector(C_B_WIDTH-1 downto 0)                                := (others => '0');
      C            : in  std_logic_vector(C_C_WIDTH-1 downto 0)                                := (others => '0');
      D            : in  std_logic_vector(C_D_WIDTH-1 downto 0)                                := (others => '0');
      CONCAT       : in  std_logic_vector(C_CONCAT_WIDTH-1 downto 0)                           := (others => '0');
      ACOUT        : out std_logic_vector(fn_dsp48_a_width(C_XDEVICEFAMILY)-1 downto 0)        := (others => '0');
      BCOUT        : out std_logic_vector(ci_dsp48_b_width-1 downto 0)                         := (others => '0');
      CARRYOUT     : out std_logic                                                             := '0';
      CARRYCASCOUT : out std_logic                                                             := '0';
      PCOUT        : out std_logic_vector(ci_dsp48_p_width-1 downto 0)                         := (others => '0');
      P            : out std_logic_vector(C_P_MSB-C_P_LSB downto 0)                            := (others => '0');

      CED          : in  std_logic                                                             := '1';  -- Ganged CE for D (Spartan)
      CED1         : in  std_logic                                                             := '1';
      CED2         : in  std_logic                                                             := '1';
      CED3         : in  std_logic                                                             := '1';
      CEA          : in  std_logic                                                             := '1';  -- Ganged CE for A (Spartan)
      CEA1         : in  std_logic                                                             := '1';
      CEA2         : in  std_logic                                                             := '1';
      CEA3         : in  std_logic                                                             := '1';
      CEA4         : in  std_logic                                                             := '1';
      CEB          : in  std_logic                                                             := '1';  -- Ganged CE for B (Spartan)
      CEB1         : in  std_logic                                                             := '1';
      CEB2         : in  std_logic                                                             := '1';
      CEB3         : in  std_logic                                                             := '1';
      CEB4         : in  std_logic                                                             := '1';
      CECONCAT     : in  std_logic                                                             := '1';  -- Ganged CE for CONCAT (Spartan)
      CECONCAT3    : in  std_logic                                                             := '1';
      CECONCAT4    : in  std_logic                                                             := '1';
      CECONCAT5    : in  std_logic                                                             := '1';
      CEC          : in  std_logic                                                             := '1';  -- Ganged CE for C (Spartan)
      CEC1         : in  std_logic                                                             := '1';
      CEC2         : in  std_logic                                                             := '1';
      CEC3         : in  std_logic                                                             := '1';
      CEC4         : in  std_logic                                                             := '1';
      CEC5         : in  std_logic                                                             := '1';
      CEM          : in  std_logic                                                             := '1';
      CEP          : in  std_logic                                                             := '1';
      CESEL        : in  std_logic                                                             := '1';  -- Ganged CE for SEL (Spartan)
      CESEL1       : in  std_logic                                                             := '1';
      CESEL2       : in  std_logic                                                             := '1';
      CESEL3       : in  std_logic                                                             := '1';
      CESEL4       : in  std_logic                                                             := '1';
      CESEL5       : in  std_logic                                                             := '1';
      SCLRD        : in  std_logic                                                             := '0';
      SCLRA        : in  std_logic                                                             := '0';
      SCLRB        : in  std_logic                                                             := '0';
      SCLRCONCAT   : in  std_logic                                                             := '0';
      SCLRC        : in  std_logic                                                             := '0';
      SCLRM        : in  std_logic                                                             := '0';
      SCLRP        : in  std_logic                                                             := '0';
      SCLRSEL      : in  std_logic                                                             := '0'
      );
    --core_if off
  end component;

  --core_if on component bip_dsp48_macro_rtl
  component bip_dsp48_macro_rtl
    generic (
      C_VERBOSITY        : integer := 0;  -- 0 = Errors 1 = +Warnings, 2 = +Notes and tips
      C_MODEL_TYPE       : integer := 0;  -- 0 = synth, 1 = RTL
      C_XDEVICEFAMILY    : string  := "virtex5";         -- Target device

      C_HAS_CE           : integer := 0;  -- 0=No CEs, 1=Has any type of CE (global, ganged, per-register)
      C_HAS_INDEP_CE     : integer := 0;  -- 0=Global CE, 1=Ganged CE for each input path, 2=Unique CE for every register

      C_HAS_CED          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(2 downto 0) enables individual CEs
      C_HAS_CEA          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(3 downto 0) enables individual CEs
      C_HAS_CEB          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(3 downto 0) enables individual CEs
      C_HAS_CEC          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(4 downto 0) enables individual CEs
      C_HAS_CECONCAT     : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(4 downto 2) enables individual CEs
      C_HAS_CEM          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(0 downto 0) enables individual CEs
      C_HAS_CEP          : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(0 downto 0) enables individual CEs
      C_HAS_CESEL        : integer := 0;  -- If C_HAS_INDEP_CE=2, to_integer(4 downto 0) enables individual CEs

      C_HAS_SCLR         : integer := 0;  -- 0=No SCLRs, 1=Has any type of SCLR (global, ganged)
      C_HAS_INDEP_SCLR   : integer := 0;  -- 0=Global CE, 1=Ganged SCLR for each input path

      C_HAS_SCLRD        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables D SCLR pin
      C_HAS_SCLRA        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables A SCLR pin
      C_HAS_SCLRB        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables B SCLR pin
      C_HAS_SCLRC        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables C SCLR pin
      C_HAS_SCLRM        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables M SCLR pin
      C_HAS_SCLRP        : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables P SCLR pin
      C_HAS_SCLRCONCAT   : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables CONCAT SCLR pin
      C_HAS_SCLRSEL      : integer := 0;  -- If C_HAS_INDEP_SCLR=1, 1 enables SEL SCLR pin

      C_HAS_CARRYCASCIN  : integer := 0;  -- 0=No CARRYCASCIN input, 1=Has CARRYCASCIN input (must be reflected in instructions)
      C_HAS_CARRYIN      : integer := 0;  -- 0=No CARRYIN input, 1=Has CARRYIN input (must be reflected in instructions)
      C_HAS_ACIN         : integer := 0;  -- 0=No ACIN input, 1=Has ACIN input (must be reflected in instructions)
      C_HAS_BCIN         : integer := 0;  -- 0=No BCIN input, 1=Has BCIN input (must be reflected in instructions)
      C_HAS_PCIN         : integer := 0;  -- 0=No PCIN input, 1=Has PCIN input (must be reflected in instructions)
      C_HAS_A            : integer := 1;  -- 0=No A input, 1=Has A input (must be reflected in instructions)
      C_HAS_B            : integer := 1;  -- 0=No B input, 1=Has B input (must be reflected in instructions)
      C_HAS_D            : integer := 1;  -- 0=No D input, 1=Has D input (must be reflected in instructions)
      C_HAS_CONCAT       : integer := 0;  -- 0=No CONCAT input, 1=Has CONCAT input (must be reflected in instructions)
      C_HAS_C            : integer := 0;  -- 0=No C input, 1=Has C input (must be reflected in instructions)
      C_A_WIDTH          : integer := ci_dsp48_b_width;  -- Width of A input bus (if present)
      C_B_WIDTH          : integer := ci_dsp48_b_width;  -- Width of B input bus (if present)
      C_C_WIDTH          : integer := ci_dsp48_c_width;  -- Width of C input bus (if present)
      C_D_WIDTH          : integer := 0;  -- Width of D input bus (if present)
      C_CONCAT_WIDTH     : integer := 0;  -- Width of CONCAT input bus (if present)
      C_P_MSB            : integer := ci_dsp48_p_width-1;  -- MSB of P output
      C_P_LSB            : integer := 0;  -- LSB of P output
      C_SEL_WIDTH        : integer := 5;  -- Width of instruction ROM select port (0 to 6, based on C_OPMODES)
      C_HAS_ACOUT        : integer := 0;  -- 0=No ACOUT port, 1=Has ACOUT cascade port
      C_HAS_BCOUT        : integer := 0;  -- 0=No BCOUT port, 1=Has BCOUT cascade port
      C_HAS_CARRYCASCOUT : integer := 0;  -- 0=No CARRYCASCOUT port, 1=Has CARRYCASCOUT cascade port
      C_HAS_CARRYOUT     : integer := 0;  -- 0=No CARRYOUT port, 1=Has CARRYOUT port
      C_HAS_PCOUT        : integer := 0;  -- 0=No PCOUT port, 1=Has PCOUT cascade port
      C_CONSTANT_1       : integer := 1;  -- Constant to allow A to pass through multiplier with no B input
      C_LATENCY          : integer := -1;  -- Core latency and register allocation; -1=Automatic, 0 to 127=Tiered, 128=Expert
      C_OPMODES          : string  := "0000000000000000000";  -- Instruction opmodes to implement (comma-separated string)
      C_REG_CONFIG       : string  := "00000000000000000000000000000000";  -- Register configuration string (ignored unless C_LATENCY=128)
      C_TEST_CORE        : integer := 0  -- 0 = normal release core behavour 1 = generate a test core
      );
    port (
      CLK          : in  std_logic                                                             := '1';  -- Rising-edge clock
      CE           : in  std_logic                                                             := '1';  -- Active-high global clock enable
      SCLR         : in  std_logic                                                             := '0';  -- Active-high global synchronous reset
      SEL          : in  std_logic_vector(C_SEL_WIDTH+boolean'pos(C_SEL_WIDTH = 0)-1 downto 0) := (others => '0');  --Guard against -1 to 0 when C_SEL_WIDTH=0
      CARRYCASCIN  : in  std_logic                                                             := '0';
      CARRYIN      : in  std_logic                                                             := '0';
      PCIN         : in  std_logic_vector(ci_dsp48_p_width-1 downto 0)                         := (others => '0');
      ACIN         : in  std_logic_vector(fn_dsp48_a_width(C_XDEVICEFAMILY)-1 downto 0)        := (others => '0');
      BCIN         : in  std_logic_vector(ci_dsp48_b_width-1 downto 0)                         := (others => '0');
      A            : in  std_logic_vector(C_A_WIDTH-1 downto 0)                                := (others => '0');
      B            : in  std_logic_vector(C_B_WIDTH-1 downto 0)                                := (others => '0');
      C            : in  std_logic_vector(C_C_WIDTH-1 downto 0)                                := (others => '0');
      D            : in  std_logic_vector(C_D_WIDTH-1 downto 0)                                := (others => '0');
      CONCAT       : in  std_logic_vector(C_CONCAT_WIDTH-1 downto 0)                           := (others => '0');
      ACOUT        : out std_logic_vector(fn_dsp48_a_width(C_XDEVICEFAMILY)-1 downto 0)        := (others => '0');
      BCOUT        : out std_logic_vector(ci_dsp48_b_width-1 downto 0)                         := (others => '0');
      CARRYOUT     : out std_logic                                                             := '0';
      CARRYCASCOUT : out std_logic                                                             := '0';
      PCOUT        : out std_logic_vector(ci_dsp48_p_width-1 downto 0)                         := (others => '0');
      P            : out std_logic_vector(C_P_MSB-C_P_LSB downto 0)                            := (others => '0');

      CED          : in  std_logic                                                             := '1';  -- Ganged CE for D (Spartan)
      CED1         : in  std_logic                                                             := '1';
      CED2         : in  std_logic                                                             := '1';
      CED3         : in  std_logic                                                             := '1';
      CEA          : in  std_logic                                                             := '1';  -- Ganged CE for A (Spartan)
      CEA1         : in  std_logic                                                             := '1';
      CEA2         : in  std_logic                                                             := '1';
      CEA3         : in  std_logic                                                             := '1';
      CEA4         : in  std_logic                                                             := '1';
      CEB          : in  std_logic                                                             := '1';  -- Ganged CE for B (Spartan)
      CEB1         : in  std_logic                                                             := '1';
      CEB2         : in  std_logic                                                             := '1';
      CEB3         : in  std_logic                                                             := '1';
      CEB4         : in  std_logic                                                             := '1';
      CECONCAT     : in  std_logic                                                             := '1';  -- Ganged CE for CONCAT (Spartan)
      CECONCAT3    : in  std_logic                                                             := '1';
      CECONCAT4    : in  std_logic                                                             := '1';
      CECONCAT5    : in  std_logic                                                             := '1';
      CEC          : in  std_logic                                                             := '1';  -- Ganged CE for C (Spartan)
      CEC1         : in  std_logic                                                             := '1';
      CEC2         : in  std_logic                                                             := '1';
      CEC3         : in  std_logic                                                             := '1';
      CEC4         : in  std_logic                                                             := '1';
      CEC5         : in  std_logic                                                             := '1';
      CEM          : in  std_logic                                                             := '1';
      CEP          : in  std_logic                                                             := '1';
      CESEL        : in  std_logic                                                             := '1';  -- Ganged CE for SEL (Spartan)
      CESEL1       : in  std_logic                                                             := '1';
      CESEL2       : in  std_logic                                                             := '1';
      CESEL3       : in  std_logic                                                             := '1';
      CESEL4       : in  std_logic                                                             := '1';
      CESEL5       : in  std_logic                                                             := '1';
      SCLRD        : in  std_logic                                                             := '0';
      SCLRA        : in  std_logic                                                             := '0';
      SCLRB        : in  std_logic                                                             := '0';
      SCLRCONCAT   : in  std_logic                                                             := '0';
      SCLRC        : in  std_logic                                                             := '0';
      SCLRM        : in  std_logic                                                             := '0';
      SCLRP        : in  std_logic                                                             := '0';
      SCLRSEL      : in  std_logic                                                             := '0'
      );
    --core_if off
  end component;

  type t_macro_config is record
    use_cascade : boolean;
    use_mult    : boolean;
    use_premux  : boolean;
    use_round   : boolean;
    num_opmodes : integer;
  end record;

  function fn_get_macro_config (
    pOPMODE : string)
    return t_macro_config;

  constant ci_tiered_latency_low_thresh  : integer := 64;
  constant ci_tiered_latency_high_thresh : integer := 127;
  constant ci_expert_latency             : integer := 128;

  constant ci_num_registers : integer := 32;

  type t_dsp48_macro_pipe is array (0 to ci_num_registers) of integer range 0 to 1;

  type t_dsp48_macro_latency is record
    used                : integer;
    pipe                : t_dsp48_macro_pipe;
    --reg_config : string(1 to ci_num_registers);
    --Works better in Rabassa as integer array
    --  keep a seperate element for feedback as some values may be different for informational purposes.
    reg_config          : t_dsp48_macro_pipe;
    -- ce remapping for concat
    orig_concat_mapping : string(1 to 3);
  end record;

  constant ci_a1       : integer := 1;
  constant ci_b1       : integer := 2;
  constant ci_c1       : integer := 3;
  constant ci_d1       : integer := 4;
  constant ci_carryin1 : integer := 5;
  constant ci_op1      : integer := 6;

  constant ci_a2       : integer := 7;
  constant ci_b2       : integer := 8;
  constant ci_c2       : integer := 9;
  constant ci_d2       : integer := 10;
  constant ci_carryin2 : integer := 11;
  constant ci_op2      : integer := 12;

  constant ci_a3       : integer := 13;
  constant ci_b3       : integer := 14;
  constant ci_c3       : integer := 15;
  constant ci_d3       : integer := 16;
  constant ci_carryin3 : integer := 17;
  constant ci_op3      : integer := 18;

  constant ci_a4       : integer := 19;
  constant ci_b4       : integer := 20;
  constant ci_c4       : integer := 21;
  constant ci_carryin4 : integer := 22;
  constant ci_concat4  : integer := 23;
  constant ci_op4      : integer := 24;

  constant ci_c5       : integer := 25;
  constant ci_m5       : integer := 26;
  constant ci_op5      : integer := 27;
  constant ci_carryin5 : integer := 28;
  constant ci_concat5  : integer := 29;

  constant ci_p6        : integer := 30;
  constant ci_carryin6  : integer := 31;
  constant ci_carryout6 : integer := 32;

  --Fields of OPMODE, defined in PDD
  constant ci_opmode_width : integer := 19;

  constant ci_opfield_abmux    : integer := 0;
  subtype ti_opfield_preadd is integer range 5 downto 1;
  constant ci_opfield_cmux     : integer := 6;
  subtype ti_opfield_xmux is integer range 8 downto 7;
  subtype ti_opfield_ymux is integer range 10 downto 9;
  subtype ti_opfield_zmux is integer range 13 downto 11;
  constant ci_opfield_subtract : integer := 14;
  constant ci_opfield_carryin  : integer := 15;
  subtype ti_opfield_carrysel is integer range 18 downto 16;

  --For Rabassa conversion
  constant ci_opfield_xmux_0 : integer := 7;
  constant ci_opfield_xmux_1 : integer := 8;

--path

  function fn_dsp48_macro_v2_1_latency (
    P_VERBOSITY       : integer;  -- 0 = Errors 1 = +Warnings, 2 = +Notes and tips
    P_MODEL_TYPE      : integer;        -- 0 = synth, 1 = RTL
    P_XDEVICEFAMILY   : string;
    P_HAS_CE          : integer;
    P_HAS_SCLR        : integer;
    P_HAS_CARRYCASCIN : integer;
    P_HAS_CARRYIN     : integer;
    P_HAS_ACIN        : integer;
    P_HAS_BCIN        : integer;
    P_HAS_ACOUT       : integer;
    P_HAS_BCOUT       : integer;
    P_HAS_A           : integer;
    P_HAS_B           : integer;
    P_HAS_D           : integer;
    P_HAS_CONCAT      : integer;
    P_A_WIDTH         : integer;        -- can't use a function here.
    P_B_WIDTH         : integer;
    P_C_WIDTH         : integer;
    P_D_WIDTH         : integer;        -- can't use a function here.
    P_CONCAT_WIDTH    : integer;
    P_SEL_WIDTH       : integer;
    P_LATENCY         : integer;
    P_OPMODES         : string;
    P_REG_CONFIG      : string
    )
    return t_dsp48_macro_latency;

  procedure remap_concat_enables (
    constant C_HAS_CONCAT        : in  integer;
    constant C_XDEVICEFAMILY     : in  string;
    constant orig_concat_mapping : in  string(1 to 3);
    signal ceconcat3_tmp         : in  std_logic;
    signal ceconcat4_tmp         : in  std_logic;
    signal ceconcat5_tmp         : in  std_logic;
    signal ceconcat3_i           : out std_logic;
    signal ceconcat4_i           : out std_logic;
    signal ceconcat5_i           : out std_logic);

  function fn_get_round_const (p_p_lsb : integer) return std_logic_vector;

  type t_opmode_type is record
    disassembled : string(1 to 50);
  end record;

  function fn_interpret_opmode (opmode : std_logic_vector(ci_opmode_width-1 downto 0)) return t_opmode_type;

  function fn_select_int (in1, in2 : integer; sel : boolean) return integer;

end package bip_dsp48_macro_pkg_v2_1;

package body bip_dsp48_macro_pkg_v2_1 is

  function fn_dsp48_macro_v2_1_check_generics (
    P_VERBOSITY       : integer;
    P_MODEL_TYPE      : integer;
    P_XDEVICEFAMILY   : string;
    P_HAS_CE          : integer;
    P_HAS_SCLR        : integer;
    P_HAS_CARRYCASCIN : integer;
    P_HAS_ACIN        : integer;
    P_HAS_BCIN        : integer;
    P_HAS_A           : integer;
    P_HAS_B           : integer;
    P_HAS_D           : integer;
    P_HAS_CONCAT      : integer;
    P_A_WIDTH         : integer;
    P_B_WIDTH         : integer;
    P_C_WIDTH         : integer;
    P_D_WIDTH         : integer;
    P_CONCAT_WIDTH    : integer;
    P_SEL_WIDTH       : integer;
    P_LATENCY         : integer;
    P_OPMODES         : string;
    P_REG_CONFIG      : string
    ) return integer is
  begin
    -- Blanket ignore all these, otherwise we need to use fine-grained
    -- exclusions to ignore various rows in the FEC and UDP condition coverage
    -- (i.e. these conditions should never be false in normal "positive" testing)
    -- If they do become false, the test will fail anyway, and no coverage
    -- would be gathered from it
    -- coverage off
    assert P_HAS_CE = 0 or P_HAS_CE = 1
      report "ERROR: xbip_dsp48_macro: C_HAS_CE out of range. Got "&integer'image(P_HAS_CE)
      severity error;
    assert P_HAS_SCLR = 0 or P_HAS_SCLR = 1
      report "ERROR: xbip_dsp48_macro: C_HAS_SCLR out of range. Got "&integer'image(P_HAS_SCLR)
      severity error;
    assert (P_CONCAT_WIDTH >= 0 and P_CONCAT_WIDTH <= 48)
      report "ERROR: xbip_dsp48_macro: C_CONCAT_WIDTH out of range. Got "&integer'image(P_CONCAT_WIDTH)
      severity error;
    if P_HAS_A = 1 then
      assert (P_A_WIDTH >= 0 and P_A_WIDTH <= fn_dsp48_a_width(P_XDEVICEFAMILY))
        report "ERROR: xbip_dsp48_macro: C_A_WIDTH out of range. Got "&integer'image(P_A_WIDTH)
        severity error;
    end if;
    if P_HAS_B = 1 then
      assert (P_B_WIDTH > 0 and P_B_WIDTH <= ci_dsp48_b_width)
        report "ERROR: xbip_dsp48_macro: C_B_WIDTH out of range. Got "&integer'image(P_B_WIDTH)
        severity error;
    end if;
    assert (P_C_WIDTH > 0 and P_C_WIDTH <= ci_dsp48_c_width)
      report "ERROR: xbip_dsp48_macro: C_C_WIDTH out of range. Got "&integer'image(P_C_WIDTH)
      severity error;
    if P_HAS_D = 1 then
      assert (P_D_WIDTH > 0 and P_D_WIDTH <= fn_dsp48_d_width(P_XDEVICEFAMILY))
        report "ERROR: xbip_dsp48_macro: C_D_WIDTH out of range. Got "&integer'image(P_D_WIDTH)
        severity error;
      assert supports_dsp48a(P_XDEVICEFAMILY) > 0 or supports_dsp48e1(P_XDEVICEFAMILY) > 0
        report "ERROR: xbip_dsp48_macro : this family does not support the D port"
        severity error;
    end if;
    assert P_HAS_ACIN = 0 or P_HAS_ACIN = 1
      report "ERROR: xbip_dsp48_macro: C_HAS_ACIN out of range"
      severity error;
    assert P_HAS_BCIN = 0 or P_HAS_BCIN = 1
      report "ERROR: xbip_dsp48_macro: C_HAS_BCIN out of range"
      severity error;
    assert P_HAS_CARRYCASCIN = 0 or P_HAS_CARRYCASCIN = 1
      report "ERROR: xbip_dsp48_macro: C_HAS_CARRYCASCIN out of range"
      severity error;
    assert P_HAS_CARRYCASCIN = 0 or supports_dsp48a(P_XDEVICEFAMILY) > 0 or supports_dsp48e(P_XDEVICEFAMILY) > 0
      report "ERROR: xbip_dsp48_macro: C_HAS_CARRYCASCIN is unavailable for this family"
      severity error;
    assert (P_SEL_WIDTH >= 0) and (P_SEL_WIDTH <= 6)
      report "ERROR : xbip_dsp48_macro: C_SEL_WIDTH must be between 0 and 6 - currently " & integer'image(P_SEL_WIDTH)
      severity error;
    -- coverage on

    --Checks to add
    --1. Opmodes which use P must have Preg (ci_p6) enabled.
    return 0;
  end function fn_dsp48_macro_v2_1_check_generics;

  function fn_dsp48_macro_v2_1_latency (
    P_VERBOSITY       : integer;
    P_MODEL_TYPE      : integer;
    P_XDEVICEFAMILY   : string;
    P_HAS_CE          : integer;
    P_HAS_SCLR        : integer;
    P_HAS_CARRYCASCIN : integer;
    P_HAS_CARRYIN     : integer;
    P_HAS_ACIN        : integer;
    P_HAS_BCIN        : integer;
    P_HAS_ACOUT       : integer;
    P_HAS_BCOUT       : integer;
    P_HAS_A           : integer;
    P_HAS_B           : integer;
    P_HAS_D           : integer;
    P_HAS_CONCAT      : integer;
    P_A_WIDTH         : integer;
    P_B_WIDTH         : integer;
    P_C_WIDTH         : integer;
    P_D_WIDTH         : integer;
    P_CONCAT_WIDTH    : integer;
    P_SEL_WIDTH       : integer;
    P_LATENCY         : integer;
    P_OPMODES         : string;
    P_REG_CONFIG      : string
    )
    return t_dsp48_macro_latency is
    variable ret_val              : t_dsp48_macro_latency;
    variable v_latency_left       : integer;
    variable v_enable_tier        : std_logic_vector(5 downto 0);  -- Rabassa had trouble with 7 downto 1
    variable v_macro_config       : t_macro_config;
    variable v_reg_config, v_pipe : string(1 to ci_num_registers);
    variable v_concat_bits        : string(1 to 3) := "000";
    variable allow_op_reg         : boolean        := false;
  begin
    v_macro_config := fn_get_macro_config(P_OPMODES);

    -- CR589878: Check to see if any registers are really enabled.  If they are
    -- not, we don't need registers on the opmode path at all.
    -- This addresses an inconsistency between the GUI and primitive models
    allow_op_reg := (P_REG_CONFIG /= "00000000000000000000000000000000");

    ---------------------------------------------------------------------------
    -- Latency is overloaded as follows:
    -- A) -1 means 'optimally pipelined' - in this case square latency
    -- B) 0 to 6 means pipe tiers (from P backwards)
    -- C) 64 to 128 is interpreted as a bit vector (ignoring the top bit which is
    -- just a flag). Hence each bit from 6 downto 1 enables a tier of registers.
    -- D) Finally, full expert mode is 128. In this case, the REG_CONFIG array
    -- is read to enable registers individually.
    ---------------------------------------------------------------------------
    --initialise all latency stages to 0.
    for i in 0 to ci_num_registers loop
      ret_val.pipe(i) := 0;
    end loop;  -- i
    ret_val.used := 0;

    -- gui trans_off
    v_enable_tier := (others => '0');
    -- gui trans_on
    -- gui insert_on
    -- v_enable_tier := int_to_slv(0, 6);
    -- gui insert_off

    --v_latency_left only has meaning in the tiered model of latency
    --which is described by -1 or 0 to 6
    if P_LATENCY = -1 or (P_LATENCY >= ci_tiered_latency_low_thresh and P_LATENCY < ci_expert_latency) then
      if P_LATENCY >= ci_tiered_latency_low_thresh and P_LATENCY < ci_expert_latency then
        -- gui trans_off
        v_enable_tier := std_logic_vector(to_unsigned(P_LATENCY, 6));
        -- gui trans_on
        -- gui insert_on
        -- v_enable_tier := int_to_slv(P_LATENCY, 6);
        -- gui insert_off

        --Will only allocate tiers that are specified to will never have excess latency
        v_latency_left := 0;
      else
        v_latency_left := p_latency;
      end if;


      --deal out latency according to generics and architecture for optimal speed
      --and resource
      --preg - first!
      if (v_latency_left /= 0 and P_LATENCY < ci_tiered_latency_low_thresh) or v_enable_tier(5) = '1' then
        v_latency_left             := v_latency_left-1;
        ret_val.pipe(ci_p6)        := ret_val.pipe(ci_p6) +1;
        ret_val.pipe(ci_carryout6) := ret_val.pipe(ci_carryout6) +1;
        ret_val.used               := ret_val.used +1;
      end if;

      if (v_latency_left /= 0 and P_LATENCY < ci_tiered_latency_low_thresh) or v_enable_tier(4) = '1' then
        v_latency_left := v_latency_left-1;
        if v_macro_config.use_mult then
          -- Only enable Mreg if multiplier is used, for significant power savings
          -- Note that multiplier is also used when (A+D) or similar is requested
          -- A typical case where the mult is not used is when CONCAT is used
          ret_val.pipe(ci_m5) := ret_val.pipe(ci_m5) +1;
        end if;
        if allow_op_reg then
          ret_val.pipe(ci_op5) := ret_val.pipe(ci_op5) +1;
        end if;
        ret_val.pipe(ci_c5)       := ret_val.pipe(ci_c5) +1;
        ret_val.pipe(ci_concat5)  := ret_val.pipe(ci_concat5) +1;
        ret_val.pipe(ci_carryin5) := ret_val.pipe(ci_carryin5) +1;
        --carryin5? Maybe for non-spartan families
        ret_val.used              := ret_val.used +1;
      end if;

      if (v_latency_left /= 0 and P_LATENCY < ci_tiered_latency_low_thresh) or v_enable_tier(3) = '1' then
        v_latency_left := v_latency_left-1;
        if allow_op_reg then
          ret_val.pipe(ci_op4) := ret_val.pipe(ci_op4) +1;
        end if;
        ret_val.pipe(ci_a4)       := ret_val.pipe(ci_a4) +1;
        ret_val.pipe(ci_b4)       := ret_val.pipe(ci_b4) +1;
        ret_val.pipe(ci_c4)       := ret_val.pipe(ci_c4) +1;
        ret_val.pipe(ci_concat4)  := ret_val.pipe(ci_concat4) +1;
        ret_val.pipe(ci_carryin4) := ret_val.pipe(ci_carryin4) +1;
        ret_val.used              := ret_val.used +1;
      end if;

      if (v_latency_left /= 0 and P_LATENCY < ci_tiered_latency_low_thresh) or v_enable_tier(2) = '1' then
        v_latency_left := v_latency_left-1;
        if allow_op_reg then
          ret_val.pipe(ci_op3) := ret_val.pipe(ci_op3) +1;
        end if;
        ret_val.pipe(ci_a3)       := ret_val.pipe(ci_a3) +1;
        ret_val.pipe(ci_b3)       := ret_val.pipe(ci_b3) +1;
        ret_val.pipe(ci_c3)       := ret_val.pipe(ci_c3) +1;
        ret_val.pipe(ci_d3)       := ret_val.pipe(ci_d3) +1;
        ret_val.pipe(ci_carryin3) := ret_val.pipe(ci_carryin3) +1;
        ret_val.used              := ret_val.used +1;
      end if;

      if (v_latency_left /= 0 and P_LATENCY < ci_tiered_latency_low_thresh and v_macro_config.use_premux) or v_enable_tier(1) = '1' then
        v_latency_left := v_latency_left-1;
        if allow_op_reg then
          ret_val.pipe(ci_op2) := ret_val.pipe(ci_op2) +1;
        end if;
        if P_HAS_ACIN = 0 then
          --Fabric stage not supported with cascade input
          ret_val.pipe(ci_a2) := ret_val.pipe(ci_a2) +1;
        end if;
        if P_HAS_BCIN = 0 then
          ret_val.pipe(ci_b2) := ret_val.pipe(ci_b2) +1;
        end if;
        ret_val.pipe(ci_c2)       := ret_val.pipe(ci_c2) +1;
        ret_val.pipe(ci_d2)       := ret_val.pipe(ci_d2) +1;
        ret_val.pipe(ci_carryin2) := ret_val.pipe(ci_carryin2) +1;
        ret_val.used              := ret_val.used +1;
      end if;

      if (v_latency_left /= 0 and P_LATENCY < ci_tiered_latency_low_thresh and v_macro_config.use_premux) or v_enable_tier(0) = '1' then
        v_latency_left := v_latency_left-1;
        if allow_op_reg then
          ret_val.pipe(ci_op1) := ret_val.pipe(ci_op1) +1;
        end if;
        if P_HAS_ACIN = 0 then
          ret_val.pipe(ci_a1) := ret_val.pipe(ci_a1) +1;
        end if;
        if P_HAS_BCIN = 0 then
          ret_val.pipe(ci_b1) := ret_val.pipe(ci_b1) +1;
        end if;
        ret_val.pipe(ci_c1)       := ret_val.pipe(ci_c1) +1;
        ret_val.pipe(ci_d1)       := ret_val.pipe(ci_d1) +1;
        ret_val.pipe(ci_carryin1) := ret_val.pipe(ci_carryin1) +1;
        ret_val.used              := ret_val.used +1;
      end if;


      --report excess latency.
      -- coverage off
      if v_latency_left > 0 then
        assert false
          report "ERROR: excess latency in xbip_dsp48_macro"
          severity error;
      end if;
      -- coverage on

      assert (p_verbosity < 2)
        report "used = "&integer'image(ret_val.used)
        severity note;
    end if;
    if P_LATENCY >= ci_expert_latency then  --expert mode.
      for i in 1 to ci_num_registers loop
        if P_REG_CONFIG(i) = '1' then
          ret_val.pipe(i) := 1;
        end if;
      end loop;  -- i in 1 to ci_num_registers
    end if;

    --Resolve Spartan3ADSP/6 carryin and opmode register enabling
    --  - this is required to ensure that carryin from fabric is not double registered
    if supports_dsp48a(P_XDEVICEFAMILY) > 0 then
      if P_SEL_WIDTH = 0 then
        --Does not need to be set when constant opcode
        ret_val.pipe(ci_op5) := 0;
      end if;
      if ret_val.pipe(ci_op5) = 1 and ret_val.pipe(ci_carryin5) = 1 and P_HAS_CARRYIN = 1 then
        -- Disable carryin reg to avoid double registering
        ret_val.pipe(ci_carryin5) := 0;
      end if;
      if ret_val.pipe(ci_carryin5) = 1 and P_HAS_CARRYCASCIN = 1 then
        -- On spartan ci_carryin5 can set a reg on the carryin(carrycascin) path. This is inconsistent with Virtex and
        -- cannot be indicated on the GUI so disable
        ret_val.pipe(ci_carryin5) := 0;
      end if;
      if ret_val.pipe(ci_op5) = 1 and P_HAS_D = 1 then
        -- when the preadder is used these registers can not be separated
        ret_val.pipe(ci_op3) := 1;
        -- set whole tier if auto or tiered
        if P_LATENCY < ci_expert_latency then
          ret_val.pipe(ci_a3)       := 1;
          ret_val.pipe(ci_b3)       := 1;
          ret_val.pipe(ci_c3)       := 1;
          ret_val.pipe(ci_d3)       := 1;
          ret_val.pipe(ci_carryin3) := 1;
        end if;
      end if;
    end if;

    --populate the registers selected into the reg_config return value
    ret_val.reg_config := ret_val.pipe;

    --When Spartan3ADSP/6 update ci_carryin5 value when ci_op5 is set
    --    - the carryin path is considered seperate and ci_carryin5 should be
    --      shown to be set. ci_carryin5 and ci_op5 are tied.
    if supports_dsp48a(P_XDEVICEFAMILY) > 0 then
      if ret_val.pipe(ci_op5) = 1 and P_HAS_CARRYIN = 1 then
        ret_val.reg_config(ci_carryin5) := 1;
      end if;
    end if;

    -- concat5 is in the fabric in the primitive model
    -- concat4 is enabled at the same time as a4/b4/c4
    -- -> synth code only uses a4/b4 for the DSP primitive, but also need to
    -- -> set concat4 for the balancing register on the D path
    -- "concat3" is equivalent to a3/b3/d3 which are in the DSP primitive
    --
    -- Don't touch the RTL (.reg_config) setup.  The registers in that model
    -- are in the correct order already, same for their enables and resets.
    --
    if P_HAS_CONCAT /= 0 then
      -- build switch key for concat registers
      -- should be able to use ci_a3 only, since ci_b3 and ci_d3 should be same value as ci_a3 for concat use
      -- integer'image doesn't work with XST (O.38.0) in this situation; it returns an 8-char string??
      -- so cast pipe integer to 0/1 integer and then to string - this now works for both MTI and XST
      -- CR588742
      v_concat_bits(1 to 3)       := integer'image(boolean'pos(ret_val.pipe(ci_a3) = 1)) & integer'image(boolean'pos(ret_val.pipe(ci_concat4) = 1)) & integer'image(boolean'pos(ret_val.pipe(ci_concat5) = 1));
      -- Code that should work:
--      v_concat_bits               := integer'image(ret_val.pipe(ci_a3)) & integer'image(ret_val.pipe(ci_concat4)) & integer'image(ret_val.pipe(ci_concat5));
      assert (p_verbosity < 1) report "v_concat_bits " & v_concat_bits(1 to 3) severity note;
      ret_val.orig_concat_mapping := v_concat_bits(1 to 3);
      case v_concat_bits(1 to 3) is
        when "000" =>
          -- nothing enabled
        when "001" =>
          -- synth
          if has_dsp48(P_XDEVICEFAMILY) then
            -- Special case for V4 - the A4/B4 registers are used in this situation
            -- rather than A3/B3/D3
            -- change to "010"
            ret_val.pipe(ci_a4) := 1;
            ret_val.pipe(ci_b4) := 1;
          else
            -- change to "100"
            ret_val.pipe(ci_a3) := 1;
            ret_val.pipe(ci_b3) := 1;
            ret_val.pipe(ci_d3) := 1;
          end if;
          ret_val.pipe(ci_concat5) := 0;
        when "010" =>
          -- change to "100" - move into a3/b3/d3
          -- This is OK for V4 and other families as it stands
          -- synth
          ret_val.pipe(ci_concat4) := 0;
          ret_val.pipe(ci_a4)      := 0;
          ret_val.pipe(ci_b4)      := 0;
          ret_val.pipe(ci_a3)      := 1;
          ret_val.pipe(ci_b3)      := 1;
          ret_val.pipe(ci_d3)      := 1;
        when "011" =>
          -- change to "110"
          -- synth
          ret_val.pipe(ci_a3)      := 1;
          ret_val.pipe(ci_b3)      := 1;
          ret_val.pipe(ci_d3)      := 1;
          ret_val.pipe(ci_concat5) := 0;
        when "100" =>
          -- OK
        when "101" =>
          -- change to "110"
          -- synth
          ret_val.pipe(ci_concat4) := 1;
          ret_val.pipe(ci_a4)      := 1;
          ret_val.pipe(ci_b4)      := 1;
          ret_val.pipe(ci_concat5) := 0;
        when "110" =>
          -- OK
        when "111" =>
          -- OK
        when others =>
          assert false
            report "ERROR: illegal concat configuration " & v_concat_bits(1 to 3)
            severity error;
      end case;
    end if;

    -- Optimisation to enable DSP48A1 carryout register when the Preg is enabled
    -- There's no checkbox on the GUI for this...
    if P_LATENCY >= ci_expert_latency and supports_dsp48a1(P_XDEVICEFAMILY) > 0 then
      if ret_val.pipe(ci_p6) = 1 then
        ret_val.pipe(ci_carryout6)       := 1;  -- used by _synth
        ret_val.reg_config(ci_carryout6) := 1;  -- used by _rtl/behv
      end if;
    end if;

    --Produce string equivalent for debug output
    -- coverage off
    if p_verbosity >= 1 then
      for w in 1 to ci_num_registers loop
        if ret_val.reg_config(w) = 1 then
          v_reg_config(w) := '1';
        else
          v_reg_config(w) := '0';
        end if;
        if ret_val.pipe(w) = 1 then
          v_pipe(w) := '1';
        else
          v_pipe(w) := '0';
        end if;
      end loop;  -- w
      report "Reg config = "&v_reg_config
        severity note;

      assert false
        report "reg_config vector: " & CR &
        "ci_a1 " & v_reg_config(ci_a1) & CR &
        "ci_a2 " & v_reg_config(ci_a2) & CR &
        "ci_a3 " & v_reg_config(ci_a3) & CR &
        "ci_a4 " & v_reg_config(ci_a4) & CR &
        "ci_b1 " & v_reg_config(ci_b1) & CR &
        "ci_b2 " & v_reg_config(ci_b2) & CR &
        "ci_b3 " & v_reg_config(ci_b3) & CR &
        "ci_b4 " & v_reg_config(ci_b4) & CR &
        "ci_c1 " & v_reg_config(ci_c1) & CR &
        "ci_c2 " & v_reg_config(ci_c2) & CR &
        "ci_c3 " & v_reg_config(ci_c3) & CR &
        "ci_c4 " & v_reg_config(ci_c4) & CR &
        "ci_c5 " & v_reg_config(ci_c5) & CR &
        "ci_carryin1 " & v_reg_config(ci_carryin1) & CR &
        "ci_carryin2 " & v_reg_config(ci_carryin2) & CR &
        "ci_carryin3 " & v_reg_config(ci_carryin3) & CR &
        "ci_carryin4 " & v_reg_config(ci_carryin4) & CR &
        "ci_carryin5 " & v_reg_config(ci_carryin5) & CR &
        "ci_op1 " & v_reg_config(ci_op1) & CR &
        "ci_op2 " & v_reg_config(ci_op2) & CR &
        "ci_op3 " & v_reg_config(ci_op3) & CR &
        "ci_op4 " & v_reg_config(ci_op4) & CR &
        "ci_op5 " & v_reg_config(ci_op5) & CR &
        "ci_concat4 " & v_reg_config(ci_concat4) & CR &
        "ci_concat5 " & v_reg_config(ci_concat5) & CR &
        "ci_m5 " & v_reg_config(ci_m5) & CR &
        "ci_p6 " & v_reg_config(ci_p6) & CR &
        "ci_carryin6 " & v_reg_config(ci_carryin6) & CR &
        "ci_carryout6 " & v_reg_config(ci_carryout6) & CR
        severity note;
      assert false
        report "pipe vector: " & CR &
        "ci_a1 " & v_pipe(ci_a1) & CR &
        "ci_a2 " & v_pipe(ci_a2) & CR &
        "ci_a3 " & v_pipe(ci_a3) & CR &
        "ci_a4 " & v_pipe(ci_a4) & CR &
        "ci_b1 " & v_pipe(ci_b1) & CR &
        "ci_b2 " & v_pipe(ci_b2) & CR &
        "ci_b3 " & v_pipe(ci_b3) & CR &
        "ci_b4 " & v_pipe(ci_b4) & CR &
        "ci_c1 " & v_pipe(ci_c1) & CR &
        "ci_c2 " & v_pipe(ci_c2) & CR &
        "ci_c3 " & v_pipe(ci_c3) & CR &
        "ci_c4 " & v_pipe(ci_c4) & CR &
        "ci_c5 " & v_pipe(ci_c5) & CR &
        "ci_carryin1 " & v_pipe(ci_carryin1) & CR &
        "ci_carryin2 " & v_pipe(ci_carryin2) & CR &
        "ci_carryin3 " & v_pipe(ci_carryin3) & CR &
        "ci_carryin4 " & v_pipe(ci_carryin4) & CR &
        "ci_carryin5 " & v_pipe(ci_carryin5) & CR &
        "ci_op1 " & v_pipe(ci_op1) & CR &
        "ci_op2 " & v_pipe(ci_op2) & CR &
        "ci_op3 " & v_pipe(ci_op3) & CR &
        "ci_op4 " & v_pipe(ci_op4) & CR &
        "ci_op5 " & v_pipe(ci_op5) & CR &
        "ci_concat4 " & v_pipe(ci_concat4) & CR &
        "ci_concat5 " & v_pipe(ci_concat5) & CR &
        "ci_m5 " & v_pipe(ci_m5) & CR &
        "ci_p6 " & v_pipe(ci_p6) & CR &
        "ci_carryin6 " & v_pipe(ci_carryin6) & CR &
        "ci_carryout6 " & v_pipe(ci_carryout6) & CR
        severity note;
    end if;

    -- coverage on

    return ret_val;

  end function fn_dsp48_macro_v2_1_latency;

  -- The RTL/behv model was always correct in the register ordering and CE connections.
  -- In the synth model, the problem was this disconnect between the GUI model and the primitive model, and where the registers were placed.
  -- In the GUI when concat5 was checked, the actual register ended up in fabric; the GUI register ordering of 3->4->5 ended up as 5->4->3 in the synth model!
  -- So, the remapping attempts to address this by shuffling the registers to get the best mapping.  The enables are remapped to reflect the register remapping.
  procedure remap_concat_enables (
    constant C_HAS_CONCAT        : in  integer;
    constant C_XDEVICEFAMILY     : in  string;
    constant orig_concat_mapping : in  string(1 to 3);
    signal ceconcat3_tmp         : in  std_logic;
    signal ceconcat4_tmp         : in  std_logic;
    signal ceconcat5_tmp         : in  std_logic;
    signal ceconcat3_i           : out std_logic;
    signal ceconcat4_i           : out std_logic;
    signal ceconcat5_i           : out std_logic) is
  begin
    if C_HAS_CONCAT /= 0 then
      case orig_concat_mapping is
        when "000" =>
          -- no change
          ceconcat3_i <= ceconcat3_tmp;
          ceconcat4_i <= ceconcat4_tmp;
          ceconcat5_i <= ceconcat5_tmp;
        when "100" =>
          -- This is the same as the "000" case
          -- XST (O.38.0) (both parsers) crashes if they are OR'd together
          -- CR588743
          ceconcat3_i <= ceconcat3_tmp;
          ceconcat4_i <= ceconcat4_tmp;
          ceconcat5_i <= ceconcat5_tmp;
        when "110" =>
          -- This is the same as the "000" case
          -- XST (O.38.0) (both parsers) crashes if they are OR'd together
          ceconcat3_i <= ceconcat3_tmp;
          ceconcat4_i <= ceconcat4_tmp;
          ceconcat5_i <= ceconcat5_tmp;
        when "001" =>
          if has_dsp48(C_XDEVICEFAMILY) then
            -- Special case for V4 - the A4/B4 registers are used rather than A3/B3
            ceconcat3_i <= ceconcat4_tmp;
            ceconcat4_i <= ceconcat5_tmp;
            ceconcat5_i <= ceconcat3_tmp;
          else
            ceconcat3_i <= ceconcat5_tmp;
            ceconcat4_i <= ceconcat4_tmp;
            ceconcat5_i <= ceconcat3_tmp;
          end if;
        when "010" =>
          ceconcat3_i <= ceconcat4_tmp;
          ceconcat4_i <= ceconcat3_tmp;
          ceconcat5_i <= ceconcat5_tmp;
        when "011" =>
          ceconcat3_i <= ceconcat4_tmp;
          ceconcat4_i <= ceconcat5_tmp;
          ceconcat5_i <= ceconcat3_tmp;
        when "111" =>
          -- This is the same as the "011" case
          -- XST (O.38.0) legacy parser crashes if they are OR'd together
          ceconcat3_i <= ceconcat4_tmp;
          ceconcat4_i <= ceconcat5_tmp;
          ceconcat5_i <= ceconcat3_tmp;
        when "101" =>
          ceconcat3_i <= ceconcat3_tmp;
          ceconcat4_i <= ceconcat5_tmp;
          ceconcat5_i <= ceconcat4_tmp;
        when others =>
          assert false
            report "ERROR: illegal concat configuration in remap_concat_enables " & orig_concat_mapping(1 to 3)
            severity error;
      end case;
    else
      -- No concat - bypass
      ceconcat3_i <= ceconcat3_tmp;
      ceconcat4_i <= ceconcat4_tmp;
      ceconcat5_i <= ceconcat5_tmp;
    end if;
  end procedure remap_concat_enables;

  --the rounding constant is 0.49999 where the binary point is determined by
  --the width of P, hence for width of 2, the constant would be 00.0111111
  function fn_get_round_const (
    p_p_lsb : integer
    )
    return std_logic_vector is
    variable ret_val : std_logic_vector(ci_dsp48_c_width-1 downto 0) := (others => '0');
  begin
    ret_val := (others => '0');
    if p_p_lsb < 2 then
      return ret_val;
    end if;
    ret_val(p_p_lsb-2 downto 0) := (others => '1');
    return ret_val;
  end function fn_get_round_const;

  function fn_get_macro_config (
    pOPMODE : string)
    return t_macro_config is
    variable v_val          : string(1 to pOPMODE'length);
    variable temp_str       : string(1 to ci_opmode_width);
    variable clear_str      : string(1 to ci_opmode_width);
    variable opmode         : std_logic_vector(ci_opmode_width-1 downto 0);
    variable len            : integer;
    variable v_uses_cascade : boolean;
    variable v_uses_mult    : boolean;
    variable v_use_premux   : boolean;
    variable v_use_round    : boolean;
    variable start          : integer;
    variable addr           : integer;
    variable cursor         : integer;
    variable ret_val        : t_macro_config;
  begin
    v_val               := pOPMODE;
    len                 := v_val'length;
    ret_val.use_cascade := false;
    ret_val.use_mult    := false;
    ret_val.use_premux  := false;
    ret_val.use_round   := false;
    ret_val.num_opmodes := 0;

    --find the first non-space character
    -- REVISIT: this loop's never executed?
    start := 0;
    for i in 1 to len loop
      if v_val(i) = '0' or v_val(i) = '1' then
        start := i;
        exit;
      end if;
    end loop;  -- i

    -- coverage off
    if start = 0 then
      assert false
        report "ERROR: xbip_dsp48_macro_v2_1: no 0/1's detected in OPMODE string"
        severity error;
      return ret_val;                   --return default  invalid
    end if;
    -- coverage on

    -- gui trans_off
    for w in temp_str'range loop
      clear_str(w) := '0';              --used to clear temp_str
    end loop;
    -- gui trans_on
    -- gui insert_on
    -- clear_str := slv_to_str(int_to_slv(0,ci_opmode_width));
    -- gui insert_off

    temp_str := clear_str;
    addr     := 0;
    cursor   := 0;

    --will this loop detect the last opmode? &&&
    for j in start to len loop
      if v_val(j) = '1' or v_val(j) = '0' then
        cursor := cursor +1;            --keep track of its length

        -- coverage off
        if cursor > ci_opmode_width then  -- check current opcode is not too big
          report "ERROR: xbip_dsp48_macro_v2_1(fn_get_macro_config): opmode string ("&pOPMODE&") contains opmode containing "
            &integer'image(cursor)&" characters, expecting "&integer'image(ci_opmode_width) severity error;
          return ret_val;
        end if;
        -- coverage on

        temp_str(cursor) := v_val(j);   --construct element string
      else

        -- coverage off
        if cursor < ci_opmode_width then  -- check current opcode is not too small
          report "ERROR: xbip_dsp48_macro_v2_1(fn_get_macro_config): opmode string ("&pOPMODE&") contains opmode containing "
            &integer'image(cursor)&" characters, expecting "&integer'image(ci_opmode_width) severity error;
          return ret_val;
        end if;
        -- coverage on

        ret_val.num_opmodes := ret_val.num_opmodes +1;
        --next word
        -- opmode := str_to_bound_slv_0(str_to_bound_str(temp_str(1 to cursor),ci_opmode_width,"0"),ci_opmode_width);
        opmode              := str_to_bound_slv_0(temp_str, ci_opmode_width);
        temp_str            := clear_str;
        cursor              := 0;
        addr                := addr+1;
        -- gui trans_off
        if opmode(ti_opfield_xmux) = "01" then
          ret_val.use_mult := true;
        end if;
        if opmode(ti_opfield_xmux) = "11" then
          ret_val.use_cascade := true;
        end if;
        -- gui trans_on
        -- gui insert_on
        -- if opmode(ci_opfield_xmux_1) = '0' and opmode(ci_opfield_xmux_0) = '1' then
        -- ret_val.use_mult := true;
        -- end if;
        -- if opmode(ci_opfield_xmux_1) = '1' and opmode(ci_opfield_xmux_0) = '1' then
        -- ret_val.use_cascade := true;
        -- end if;
        -- gui insert_off
        if opmode(ci_opfield_cmux) = '1' then
          ret_val.use_round := true;
        end if;
        if opmode(ci_opfield_abmux) = '1' then
          ret_val.use_premux := true;
        end if;
      end if;
      if j = len and (v_val(j) = '1' or v_val(j) = '0') then

        -- coverage off
        if cursor < ci_opmode_width then  -- check current opcode is not too small
          report "ERROR: xbip_dsp48_macro_v2_1(fn_get_macro_config): opmode string ("&pOPMODE&") contains opmode containing "
            &integer'image(cursor)&" characters, expecting "&integer'image(ci_opmode_width) severity error;
          return ret_val;
        end if;
        -- coverage on

        ret_val.num_opmodes := ret_val.num_opmodes +1;
        --next word
        -- opmode := str_to_bound_slv_0(str_to_bound_str(temp_str(1 to cursor),ci_opmode_width,"0"),ci_opmode_width);
        opmode              := str_to_bound_slv_0(temp_str, ci_opmode_width);
        temp_str            := clear_str;
        cursor              := 0;
        addr                := addr+1;
        -- gui trans_off
        if opmode(ti_opfield_xmux) = "01" then
          ret_val.use_mult := true;
        end if;
        if opmode(ti_opfield_xmux) = "11" then
          ret_val.use_cascade := true;
        end if;
        -- gui trans_on
        -- gui insert_on
        -- if opmode(ci_opfield_xmux_1) = '0' and opmode(ci_opfield_xmux_0) = '1' then
        -- ret_val.use_mult := true;
        -- end if;
        -- if opmode(ci_opfield_xmux_1) = '1' and opmode(ci_opfield_xmux_0) = '1' then
        -- ret_val.use_cascade := true;
        -- end if;
        -- gui insert_off
        if opmode(ci_opfield_cmux) = '1' then
          ret_val.use_round := true;
        end if;
        if opmode(ci_opfield_abmux) = '1' then
          ret_val.use_premux := true;
        end if;
      end if;
    end loop;  -- j

    -- Comment-in for debug (no p_verbosity passed in)
--    assert false report "fn_get_macro_config: Read " & integer'image(ret_val.num_opmodes) & " opmodes" severity note;

    return ret_val;
  end function fn_get_macro_config;

  function fn_interpret_opmode (
    opmode : std_logic_vector(ci_opmode_width-1 downto 0)
    )
    return t_opmode_type is
    variable ret_val : t_opmode_type;
    variable temp    : string(1 to 37);
  begin
    temp(1 to 6) := " P <= ";
    case opmode(ti_opfield_zmux) is
      when "000"  => temp(7 to 13) := "0      ";
      when "001"  => temp(7 to 13) := "PCIN   ";
      when "010"  => temp(7 to 13) := "P      ";
      when "011"  => temp(7 to 13) := "C      ";
      when "100"  => temp(7 to 13) := "sh PCIN";  -- REVISIT: never used?
      when "101"  => temp(7 to 13) := "sh P   ";
      when "110"  => temp(7 to 13) := "0      ";
      when "111"  => temp(7 to 13) := "0      ";
      when others => temp(7 to 13) := "?      ";
    end case;

    if opmode(ci_opfield_subtract) = '1' then
      temp(14 to 18) := " -  (";
    else
      temp(14 to 18) := " +  (";
    end if;

    case opmode(ti_opfield_ymux) is
      when "00"   => temp(19 to 22) := "    ";
      when "01"   => temp(19 to 22) := "    ";
      when "10"   => temp(19 to 22) := "    ";  -- REVISIT: never used?
      when "11"   => temp(19 to 22) := "C + ";
                     -- coverage off
      when others => null;
                     -- coverage on
    end case;

    case opmode(ti_opfield_xmux) is
      when "00"   => temp(23 to 25) := "0  ";
      when "01"   => temp(23 to 25) := "A*B";
      when "10"   => temp(23 to 25) := "P  ";
      when "11"   => temp(23 to 25) := "A:B";
                     -- coverage off
      when others => null;
                     -- coverage on
    end case;

    temp(26 to 37)                := " + CARRYIN )";
    ret_val.disassembled(1 to 37) := temp;
    return ret_val;
  end function fn_interpret_opmode;

  function fn_select_int (in1, in2 : integer; sel : boolean) return integer is
  begin
    if sel then
      return in1;
    else
      return in2;
    end if;
  end function fn_select_int;

end package body bip_dsp48_macro_pkg_v2_1;
